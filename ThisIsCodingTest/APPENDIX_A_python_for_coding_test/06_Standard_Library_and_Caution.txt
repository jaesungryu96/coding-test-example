6. 주요 라이브러르의 문법과 유의점

표준 라이브러리란 특정한 프로그래밍 언어에서 자주 사용되는 표준 소스코드를 미리 구현해 놓은 라이브러리를 의미한다. C++ 코딩의 경우에는
C++ STL(Standard Template Library)를 이용할 수 있으며, 파이썬의 경우에는 표준 라이브러리를 이용할 수 있다.

파이썬에서 지원하는 표준 라이브러리는 굉장히 다양하지만, 6가지 라이브러리는 꼭 알아두어야 한다.

1. 내장 함수 : print(), input()과 같은 기본 입출력 기능부터 sorted()와 같은 정렬 기능을 포함하고 있는 기본 내장 라이브러리이다.

2. itertools : 파이썬에서 반복되는 형태의 데이터를 처리하는 기능을 제공하는 라이브러리이다. 순열과 조합 라이브러리를 제공한다.

3. heapq : 힙(Heap) 기능을 제공하는 라이브러리이다. 우선순위 큐 기능을 구현하기 위해 사용한다.

4. bisect : 이진 탐색(Binary Search) 기능을 제공하는 라이브러리이다.

5. collections : 덱(deque), 카운터(Counter) 등의 유용한 자료구조를 포함하고 있는 라이브러리이다.

6. math : 필수적인 수학적 기능을 제공하는 라이브러리이다. 팩토리얼, 제곱근, 최대공약수(GCD), 삼각함수 관련 함수부터 파이(pi)와 같은 상수를 포함하고 있다.

내장 함수

내장 함수에서 알아두면 좋은 메서드들은 다음과 같다.

sum() : iterable 객체를 입력받아 모든 원소의 합을 반환한다.

min() : 파라미터가 2개 이상 들어왔을 때 가장 작은 값을 반환한다.

max() : 파라미터가 2개 이상 들어왔을 때 가장 큰 값을 반환한다.

eval() : 수학 수식이 문자열 형식으로 들어오면 해당 수식을 계산한 결과를 반환한다.

sorted() : iterable 객체를 입력받아 정렬된 결과를 반환한다. key 속성으로 정렬 기준을 명시할 수 있고, reverse 속성을 통해 역순 여부를 설정할 수 있다.

itertools

itertools는 파이썬에서 반복되는 데이터를 처리하는 기능을 포함하고 있는 라이브러리이다. 제공하는 클래스는 매우 다양하지만, 코딩 테스트에서 가장
유용하게 사용할 수 있는 클래스는 permutations, combinations이다.

permutations 는 iterable 객체에서 r 개의 데이터를 뽑아 일렬로 나열하는 모든 경우를 계산해준다.

-----------------------------------------------------------------------------------------------------------------------
from itertools import permutations

data = ['A', 'B', 'C']

result = list(permutations(data, 3))

print(result)

# [('A', 'B', 'C'), ('A', 'C', 'B'), ('B', 'A', 'C'), ('B', 'C', 'A'), ('C', 'A', 'B'), ('C', 'B', 'A')]
-----------------------------------------------------------------------------------------------------------------------

combinations 는 iterable 객체에서 r 개의 데이터를 뽑아 순서를 고려하지 않고 나욜하는 모든 경우를 계산한다.

-----------------------------------------------------------------------------------------------------------------------
from itertools import combinations

data = ['A', 'B', 'C']

result = list(combinations(data, 2))

print(result)

# [('A', 'B'), ('B', 'C'), ('A', 'C')]
-----------------------------------------------------------------------------------------------------------------------

product 는 permutations 와 마찬가지로 iterable 객체에서 r 개의 데이터를 뽑아 일렬로 나열하는 모든 경우를 계산한다. 다만 원소를 중복하여 뽑는다.
뽑고자 하는 데이터의 수를 repeat 속성값으로 넣어준다.

-----------------------------------------------------------------------------------------------------------------------
from itertools import product

data = ['A', 'B', 'C']
result = list(product(data, repeat=2))

print(result)

# [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'B'), ('B', 'C'), ('C', 'A'), ('C', 'B'), ('C', 'C')]
-----------------------------------------------------------------------------------------------------------------------

combinations_with_replacement 는 iterable 객체에서 r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모든 경우를 계산한다. 다만 원소를 중복하여 뽑는다.

-----------------------------------------------------------------------------------------------------------------------
from itertools import combinations_with_replacement

data = ['A', 'B', 'C']
result = list(combinations_with_replacement(data, 2))

print(result)

# [('A', 'A'), ('A', 'B'), ('A', 'C'), ('B', 'B'), ('B', 'C'), ('C', 'C')]
-----------------------------------------------------------------------------------------------------------------------

heapq

파이썬에서는 힙(Heap) 기능을 위해 heapq 라이브러리를 제공한다. heapq는 다익스트라 최단 경로 알고리즘을 포함해 다양한 알고리즘에서 우선순위 큐
기능을 이용하고자 할 때 사용된다.
파이썬의 힙은 최소힙(Min Heap)으로 구성되어 있으므로 단순히 원소를 힙에 넣었다가 빼는 것만으로도 시간 복잡도 O(NlogN)에 오름차순 정렬이 완료된다.

-----------------------------------------------------------------------------------------------------------------------
import heapq

def heapsort(iterable):
    h = []
    result = []

    for value in iterable:
        heapq.heappush(h, value)

    for i in range(len(h)):
        result.append(heapq.heappop(h))

    return result

result = heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])
print(result)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
-----------------------------------------------------------------------------------------------------------------------

파이썬에서는 최대힙을 제공하지 않기 때문에 최대힙을 사용할 때는 원소의 부호를 임시로 변경하는 방식을 사용한다.
힙에서 원소를 삽입하기 전에 잠시 부호를 반대로 바꾸었다가, 힙에서 원소를 꺼낸 뒤에 다시 원소의 부호를 바꾸면 된다.

-----------------------------------------------------------------------------------------------------------------------
import heapq


def heapsort(iterable):
    h = []
    result = []

    for value in iterable:
        heapq.heappush(h, -value)

    for i in range(len(h)):
        result.append(-heapq.heappop(h))
    return result
-----------------------------------------------------------------------------------------------------------------------

bisect

파이썬에서는 이진 탐색을 쉽게 구현할 수 있도록 bisect 라이브러리를 제공한다. bisect 라이브러리는 '정렬된 배열'에서 특정한 원소를 찾아야 할 때
매우 효과적으로 사용된다. bisect 라이브러리에서는 bisect_left() 함수와 bisect_right() 함수가 가장 중요하게 사용되며, 이 두 함수의 시간
복잡도는 O(logN)이다.

bisect_left(a, x) : 정렬된 순서를 유지하면서 리스트 a에 데이터 x를 삽입할 가장 왼쪽 인덱스를 찾는 메서드
bisect_right(a, x) : 정렬된 순서를 유지하면서 리스트 a에 데이터 x를 삽입할 가장 오른쪽 인덱스를 찾는 메서드

a = [1, 2, 4, 4, 8] 가 있을 때, 새롭게 데이터 4를 삽입하려 한다고 가정하자.

bisect_left(a, 4) -> 2, 4 사이
bisect_right(a, 4) -> 4, 8 사이

count_by_range(a, left_value, right_value) 함수는 정렬된 리스트에서 값이 [left_value, right_value]에 속하는 데이터의 개수를 반환한다.
원소의 값을 x라고 할 때, left_value <= x <= right_value 인 원소의 개수를 O(logN)으로 빠르게 계산할 수 있다.

-----------------------------------------------------------------------------------------------------------------------
from bisect import bisect_left, bisect_right


def count_by_range(a, left_value, right_value):
    right_index = bisect_right(a, right_value)
    left_index = bisect_left(a, left_value)
    return right_index - left_index

a = [1, 2, 3, 3, 3, 3, 4, 4, 8, 9]

print(count_by_range(a, 4, 4))  # 2

print(count_by_range(a, -1, 3))  # 6
-----------------------------------------------------------------------------------------------------------------------

collections

collections 라이브러리는 유용한 자료구조를 제공하는 표준 라이브러리다. 유용하게 사용되는 클래스는 deque와 Counter이다. 파이썬에서는 deque
를 사용해 큐를 구현한다. 파이썬의 기본 리스트 자료형은 데이터 삽입, 삭제 등의 다양한 기능을 제공한다. 이는 '가장 뒤쪽 원소'를 기준으로 수행되기
때문에 원소의 개수가 많을 때 가장 앞의 원소를 처리할 때는 많은 시간이 소요될 수 있다.

                        리스트             deque
가장 앞쪽에 원소 추가       O(N)              O(1)   appendleft
가장 뒤쪽에 원소 추가       O(N)              O(1)   append
가장 앞쪽에 있는 원소 제거   O(N)              O(1)   popleft
가장 뒤쪽에 있는 원소 제거   O(N)              O(1)   pop

deque에서는 리스트 자료형과 다르게 인덱싱, 슬라이싱 등의 기능은 사용할 수 없지만, 연속적으로 나열된 데이터의 시작 부분이나 끝부분에 데이터를
삽입하거나 삭제할 때는 매우 효과적으로 사용될 수 있다.

Counter는 등장 횟수를 세는 기능을 제공한다. 구체적으로 리스트와 같은 iterable 객체가 주어졌을 때, 해당 객체 내부의 원소가 몇 번씩 등장했는지를
알려준다.

math

수학적인 기능을 포함하고 있는 라이브러리로 수학 계산을 요구하는 문제를 만났을 때 효과적으로 사용할 수 있다.

-----------------------------------------------------------------------------------------------------------------------
import math

print(math.factorial(5))  # 5의 팩토리얼

print(math.sqrt(7))  # 7의 제곱근

print(math.gcd(21, 14))  # 21, 14의 최대 공약수

print(math.pi)  # 파이(pi) 출력
print(math.e)  # 자연상수 e 출력
-----------------------------------------------------------------------------------------------------------------------